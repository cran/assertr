<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Tony Fischetti" />

<meta name="date" content="2015-06-26" />

<title>Assertive R Programming with assertr</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css,body%20%7B%0A%20%20background%2Dcolor%3A%20%23fff%3B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20max%2Dwidth%3A%20700px%3B%0A%20%20overflow%3A%20visible%3B%0A%20%20padding%2Dleft%3A%202em%3B%0A%20%20padding%2Dright%3A%202em%3B%0A%20%20font%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0A%20%20font%2Dsize%3A%2014px%3B%0A%20%20line%2Dheight%3A%201%2E35%3B%0A%7D%0A%0A%23header%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0A%0A%23TOC%20%7B%0A%20%20clear%3A%20both%3B%0A%20%20margin%3A%200%200%2010px%2010px%3B%0A%20%20padding%3A%204px%3B%0A%20%20width%3A%20400px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20border%2Dradius%3A%205px%3B%0A%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20font%2Dsize%3A%2013px%3B%0A%20%20line%2Dheight%3A%201%2E3%3B%0A%7D%0A%20%20%23TOC%20%2Etoctitle%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%20%20font%2Dsize%3A%2015px%3B%0A%20%20%20%20margin%2Dleft%3A%205px%3B%0A%20%20%7D%0A%0A%20%20%23TOC%20ul%20%7B%0A%20%20%20%20padding%2Dleft%3A%2040px%3B%0A%20%20%20%20margin%2Dleft%3A%20%2D1%2E5em%3B%0A%20%20%20%20margin%2Dtop%3A%205px%3B%0A%20%20%20%20margin%2Dbottom%3A%205px%3B%0A%20%20%7D%0A%20%20%23TOC%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dleft%3A%20%2D2em%3B%0A%20%20%7D%0A%20%20%23TOC%20li%20%7B%0A%20%20%20%20line%2Dheight%3A%2016px%3B%0A%20%20%7D%0A%0Atable%20%7B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dcolor%3A%20%23DDDDDD%3B%0A%20%20border%2Dstyle%3A%20outset%3B%0A%20%20border%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0A%20%20border%2Dwidth%3A%202px%3B%0A%20%20padding%3A%205px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%20%20line%2Dheight%3A%2018px%3B%0A%20%20padding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0A%20%20border%2Dleft%2Dstyle%3A%20none%3B%0A%20%20border%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Ap%20%7B%0A%20%20margin%3A%200%2E5em%200%3B%0A%7D%0A%0Ablockquote%20%7B%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20padding%3A%200%2E25em%200%2E75em%3B%0A%7D%0A%0Ahr%20%7B%0A%20%20border%2Dstyle%3A%20solid%3B%0A%20%20border%3A%20none%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23777%3B%0A%20%20margin%3A%2028px%200%3B%0A%7D%0A%0Adl%20%7B%0A%20%20margin%2Dleft%3A%200%3B%0A%7D%0A%20%20dl%20dd%20%7B%0A%20%20%20%20margin%2Dbottom%3A%2013px%3B%0A%20%20%20%20margin%2Dleft%3A%2013px%3B%0A%20%20%7D%0A%20%20dl%20dt%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%7D%0A%0Aul%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%7D%0A%20%20ul%20li%20%7B%0A%20%20%20%20list%2Dstyle%3A%20circle%20outside%3B%0A%20%20%7D%0A%20%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dbottom%3A%200%3B%0A%20%20%7D%0A%0Apre%2C%20code%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20color%3A%20%23333%3B%0A%7D%0Apre%20%7B%0A%20%20white%2Dspace%3A%20pre%2Dwrap%3B%20%20%20%20%2F%2A%20Wrap%20long%20lines%20%2A%2F%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20margin%3A%205px%200px%2010px%200px%3B%0A%20%20padding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Acode%20%7B%0A%20%20font%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0A%20%20font%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0A%20%20padding%3A%202px%200px%3B%0A%7D%0A%0Adiv%2Efigure%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0A%20%20background%2Dcolor%3A%20%23FFFFFF%3B%0A%20%20padding%3A%202px%3B%0A%20%20border%3A%201px%20solid%20%23DDDDDD%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20margin%3A%200%205px%3B%0A%7D%0A%0Ah1%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%20%20font%2Dsize%3A%2035px%3B%0A%20%20line%2Dheight%3A%2040px%3B%0A%7D%0A%0Ah2%20%7B%0A%20%20border%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20padding%2Dbottom%3A%202px%3B%0A%20%20font%2Dsize%3A%20145%25%3B%0A%7D%0A%0Ah3%20%7B%0A%20%20border%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20font%2Dsize%3A%20120%25%3B%0A%7D%0A%0Ah4%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0A%20%20margin%2Dleft%3A%208px%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Ah5%2C%20h6%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23ccc%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Aa%20%7B%0A%20%20color%3A%20%230033dd%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%7D%0A%20%20a%3Ahover%20%7B%0A%20%20%20%20color%3A%20%236666ff%3B%20%7D%0A%20%20a%3Avisited%20%7B%0A%20%20%20%20color%3A%20%23800080%3B%20%7D%0A%20%20a%3Avisited%3Ahover%20%7B%0A%20%20%20%20color%3A%20%23BB00BB%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%0A%2F%2A%20Class%20described%20in%20https%3A%2F%2Fbenjeffrey%2Ecom%2Fposts%2Fpandoc%2Dsyntax%2Dhighlighting%2Dcss%0A%20%20%20Colours%20from%20https%3A%2F%2Fgist%2Egithub%2Ecom%2Frobsimmons%2F1172277%20%2A%2F%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Keyword%20%2A%2F%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%2F%2A%20DataType%20%2A%2F%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%2F%2A%20DecVal%20%28decimal%20values%29%20%2A%2F%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20BaseN%20%2A%2F%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Float%20%2A%2F%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Char%20%2A%2F%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20String%20%2A%2F%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%2F%2A%20Comment%20%2A%2F%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%2F%2A%20OtherToken%20%2A%2F%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20AlertToken%20%2A%2F%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Function%20calls%20%2A%2F%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%2F%2A%20ErrorTok%20%2A%2F%0A%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">Assertive R Programming with assertr</h1>
<h4 class="author"><em>Tony Fischetti</em></h4>
<h4 class="date"><em>2015-06-26</em></h4>
</div>


<p>In data analysis workflows that depend on un-sanitized data sets from external sources, it’s very common that errors in data bring an analysis to a screeching halt. Oftentimes, these errors occur late in the analysis and provide no clear indication of which datum caused the error.</p>
<p>On occasion, the error resulting from bad data won’t even appear to be a data error at all. Still worse, errors in data will pass through analysis without error, remain undetected, and produce inaccurate results.</p>
<p>The solution to the problem is to provide as much information as you can about how you expect the data to look up front so that any deviation from this expectation can be dealt with immediately. This is what the <code>assertr</code> package tries to make dead simple.</p>
<p>Essentially, <code>assertr</code> provides a suite of functions designed to verify assumptions about data early in an analysis pipeline. This package needn’t be used with the <code>magrittr</code>/<code>dplyr</code> piping mechanism but the examples in this vignette will use them to enhance clarity.</p>
<div id="concrete-data-errors" class="section level3">
<h3>concrete data errors</h3>
<p>Let’s say, for example, that the R’s built-in car dataset, <code>mtcars</code>, was not built-in but rather procured from an external source that was known for making errors in data entry or coding.</p>
<p>In particular, the mtcars dataset looks like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(mtcars)</code></pre>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<p>But let’s pretend that the data we got accidentally negated the 5th mpg value:</p>
<pre class="sourceCode r"><code class="sourceCode r">our.data &lt;-<span class="st"> </span>mtcars
our.data$mpg[<span class="dv">5</span>] &lt;-<span class="st"> </span>our.data$mpg[<span class="dv">5</span>] *<span class="st"> </span>-<span class="dv">1</span>
our.data[<span class="dv">4</span>:<span class="dv">6</span>,]</code></pre>
<pre><code>##                     mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Hornet 4 Drive     21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout -18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant            18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<p>Whoops!</p>
<p>If we wanted to find the average miles per gallon for each number of engine cylinders, we might do so like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)

our.data %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Source: local data frame [3 x 2]
## 
##   cyl  avg.mpg
## 1   4 26.66364
## 2   6 19.74286
## 3   8 12.42857</code></pre>
<p>This indicates that the average miles per gallon for a 8 cylinder car is a lowly 12.43. However, in the correct dataset it’s really just over 15. Data errors like that are extremely easy to miss because it doesn’t cause an error, and the results look reasonable.</p>
</div>
<div id="enter-assertr" class="section level3">
<h3>enter assertr</h3>
<p>To combat this, we might want to use assertr’s <code>verify</code> function to make sure that <code>mpg</code> is a positive number:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(assertr)

our.data %&gt;%
<span class="st">  </span><span class="kw">verify</span>(mpg &gt;=<span class="st"> </span><span class="dv">0</span>) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Error in verify(., mpg &gt;= 0): verification failed! (1 failure)</code></pre>
<p>If we had done this, we would have caught this data error.</p>
<p>The <code>verify</code> function takes a data frame (its first argument is provided by the <code>%&gt;%</code> operator), and a logical (boolean) expression. Then, <code>verify</code> evaluates that expression using the scope of the provided data frame. If any of the logical values of the expression’s result are <code>FALSE</code>, <code>verify</code> will raise an error that terminates any further processing of the pipeline.</p>
<p>We could have also written this assertion using <code>assertr</code>’s <code>assert</code> function…</p>
<pre class="sourceCode r"><code class="sourceCode r">our.data %&gt;%
<span class="st">  </span><span class="kw">assert</span>(<span class="kw">within_bounds</span>(<span class="dv">0</span>,<span class="ot">Inf</span>), mpg) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Error: 
## Vector 'mpg' violates assertion 'within_bounds' 1 time (value [-18.7] at index 5)</code></pre>
<p>The <code>assert</code> function takes a data frame, a predicate function, and an arbitrary number of columns to apply the predicate function to. The predicate function (a function that returns a logical/boolean value) is then applied to every element of the columns selected, and will raise an error when if it finds violations.</p>
<p>Internally, the <code>assert</code> function uses <code>dplyr</code>’s <code>select</code> function to extract the columns to test the predicate function on. This allows for complex assertions. Let’s say we wanted to make sure that all values in the dataset are <em>greater</em> than zero (except <code>mpg</code>):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(assertr)

our.data %&gt;%
<span class="st">  </span><span class="kw">assert</span>(<span class="kw">within_bounds</span>(<span class="dv">0</span>,<span class="ot">Inf</span>, <span class="dt">include.lower=</span><span class="ot">FALSE</span>), -mpg) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Error: 
## Vector 'vs' violates assertion 'within_bounds' 18 times (e.g. [0] at index 1)
## Vector 'am' violates assertion 'within_bounds' 19 times (e.g. [0] at index 4)</code></pre>
</div>
<div id="verify-vs.assert" class="section level3">
<h3>verify vs. assert</h3>
<p>The first noticable difference between <code>verify</code> and <code>assert</code> is that <code>verify</code> takes an expression, and <code>assert</code> takes a predicate and columns to apply it to. This might make the <code>verify</code> function look more elegant–but there’s an important drawback. <code>verify</code> has to evaluate the entire expression first, and <em>then</em> check if there were any violations. Because of this, <code>verify</code> can’t tell you the offending datum.</p>
<p>One important drawback to <code>assert</code>, and a consequence of its application of the predicate to <em>columns</em>, is that <code>assert</code> can’t confirm assertions about the data structure <em>itself</em>. For example, let’s say we were reading a dataset from disk that we know has more than 100 observations; we could write a check of that assumption like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;a-data-file.csv&quot;</span>)
dat %&gt;%
<span class="st">  </span><span class="kw">verify</span>(<span class="kw">nrow</span>(.) &gt;<span class="st"> </span><span class="dv">100</span>) %&gt;%
<span class="st">  </span>....</code></pre>
<p>This is a powerful advantage over <code>assert</code>… but <code>assert</code> has one more advantage of its own that we heretofore ignored.</p>
</div>
<div id="assertrs-predicates" class="section level3">
<h3>assertr’s predicates</h3>
<p><code>assertr</code>’s predicates, both built-in and custom, make <code>assert</code> very powerful. The three predicates that are built in to <code>assertr</code> are</p>
<ul>
<li><code>not_na</code> - that checks if an element is not NA</li>
<li><code>within_bounds</code> - that returns a predicate function that checks if a numeric value falls within the bounds supplied, and</li>
<li><code>in_set</code> - that returns a predicate function that checks if an element is a member of the set supplied.</li>
</ul>
<p>We’ve already seen <code>within_bounds</code> in action… let’s use the <code>in_set</code> function to make sure that there are only 0s and 1s (automatic and manual, respectively) values in the <code>am</code> column…</p>
<pre class="sourceCode r"><code class="sourceCode r">our.data %&gt;%
<span class="st">  </span><span class="kw">assert</span>(<span class="kw">in_set</span>(<span class="dv">0</span>,<span class="dv">1</span>), am) %&gt;%
<span class="st">  </span>...</code></pre>
<p>If we were reading a dataset that contained a column representing boroughs of New York City (named <code>BORO</code>), we can verify that there are no mis-spelled or otherwise unexpected boroughs like so…</p>
<pre class="sourceCode r"><code class="sourceCode r">boroughs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Bronx&quot;</span>, <span class="st">&quot;Manhattan&quot;</span>, <span class="st">&quot;Queens&quot;</span>, <span class="st">&quot;Brooklyn&quot;</span>, <span class="st">&quot;Staten Island&quot;</span>)

<span class="kw">read.csv</span>(<span class="st">&quot;a-dataset.csv&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">assert</span>(<span class="kw">in_set</span>(boroughs), BORO) %&gt;%
<span class="st">  </span>...</code></pre>
<p>Rad!</p>
</div>
<div id="custom-predicates" class="section level3">
<h3>custom predicates</h3>
<p>A convenient feature of <code>assertr</code> is that it makes the construction of custom predicate functions easy.</p>
<p>In order to make a custom predicate, you only have to specify cases where the predicate should return FALSE. Let’s say that a dataset has an ID column (named <code>ID</code>) that we want to check is not an empty string. We can create a predicate like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">not.empty.p &lt;-<span class="st"> </span>function(x) if(x==<span class="st">&quot;&quot;</span>) <span class="kw">return</span>(<span class="ot">FALSE</span>)</code></pre>
<p>and apply it like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read.csv</span>(<span class="st">&quot;another-dataset.csv&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">assert</span>(not.empty.p, ID) %&gt;%
<span class="st">  </span>...</code></pre>
<p>Let’s say that the ID column is always a 7-digit number. We can confirm that all the IDs are 7-digits by defining the following predicate:</p>
<pre class="sourceCode r"><code class="sourceCode r">seven.digit.p &lt;-<span class="st"> </span>function(x) <span class="kw">nchar</span>(x)==<span class="dv">7</span></code></pre>
<p>A powerful consequence of this easy creation of predicates is that the <code>assert</code> function lends itself to use with lambda predicates (unnamed predicates that are only used once). The check above might be better written as</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read.csv</span>(<span class="st">&quot;another-dataset.csv&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">assert</span>(function(x) <span class="kw">nchar</span>(x)==<span class="dv">7</span>, ID) %&gt;%
<span class="st">  </span>...</code></pre>
<p>Neat-o!</p>
</div>
<div id="enter-insist-and-predicate-generators" class="section level3">
<h3>enter <code>insist</code> and predicate ‘generators’</h3>
<p>Very often, there is a need to dynamically determine the predicate function to be used based on the vector being checked.</p>
<p>For example, to check to see if every element of a vector is within <em>n</em> standard deviations of the mean, you need to create a <code>within_bounds</code> predicate <em>after</em> dynamically determining the bounds by reading and computing on the vector itself.</p>
<p>To this end, the <code>assert</code> function is no good; it just applies a raw predicate to a vector. We need a function like <code>assert</code> that will apply predicate <em>generators</em> to vectors, return predicates, and <em>then</em> perform <code>assert</code>-like functionality by checking each element of the vectors with its respective custom predicate. This is precisely what <code>insist</code> does.</p>
<p>This is all much simpler than it may sound. Hopefully, the examples will clear up any confusion.</p>
<p>The primary use case for <code>insist</code> is in conjunction with the <code>within_n_sds</code> or <code>within_n_mads</code> predicate generator.</p>
<p>Suppose we wanted to check that every <code>mpg</code> value in the <code>mtcars</code> data set was within 3 standard deviations of the mean before finding the average miles per gallon for each number of engine cylinders. We could write something like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">insist</span>(<span class="kw">within_n_sds</span>(<span class="dv">3</span>), mpg) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Source: local data frame [3 x 2]
## 
##   cyl  avg.mpg
## 1   4 26.66364
## 2   6 19.74286
## 3   8 15.10000</code></pre>
<p>Notice what happens when we drop that z-score to 2 stardard deviations from the mean</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">insist</span>(<span class="kw">within_n_sds</span>(<span class="dv">2</span>), mpg) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Error: 
## Vector 'mpg' violates assertion 'within_n_sds' 2 times (e.g. [32.4] at index 18)</code></pre>
<p>Execution of the pipeline was halted. But now we know exactly which data point (and column) violated the predicate that <code>within_n_sds(3)(mtcars$mpg)</code> returned.</p>
<p>Now that’s an efficient car!</p>
<p>After the predicate generator, <code>insist</code> takes an arbitrary number of columns just like <code>assert</code> using the syntax of <code>dplyr</code>’s <code>select</code> function. If you wanted to check that everything in mtcars is within 10 standard deviations of the mean (of each column vector), you can do so like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">insist</span>(<span class="kw">within_n_sds</span>(<span class="dv">10</span>), mpg:carb) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Source: local data frame [3 x 2]
## 
##   cyl  avg.mpg
## 1   4 26.66364
## 2   6 19.74286
## 3   8 15.10000</code></pre>
<p>Aces!</p>
<p>I chose to use <code>within_n_sds</code> in this example because people are familiar z-scores. However, for most practical purposes, the related predicate generator <code>within_n_mads</code> is more useful.</p>
<p>The problem with <code>within_n_sds</code> is the mean and standard deviation are so heavily influenced by outliers, their very presence will compromise attempts to identify them using these statistics. In contrast with <code>within_n_sds</code>, <code>within_n_mads</code> uses the robust statistics, median and median absolute deviation, to identify potentially erroneous data points.</p>
<p>For example, the vector <code>&lt;7.4, 7.1, 7.2, 72.1&gt;</code> almost certainly has an erroneous data point, but <code>within_n_sds(2)</code> will fail to detect it.</p>
<pre class="sourceCode r"><code class="sourceCode r">example.vector &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">7.4</span>, <span class="fl">7.1</span>, <span class="fl">7.2</span>, <span class="fl">72.1</span>)
<span class="kw">within_n_sds</span>(<span class="dv">2</span>)(example.vector)(example.vector)</code></pre>
<pre><code>## [1] TRUE TRUE TRUE TRUE</code></pre>
<p>whereas <code>within_n_mads</code> will detect it at even lower levels of power….</p>
<pre class="sourceCode r"><code class="sourceCode r">example.vector &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">7.4</span>, <span class="fl">7.1</span>, <span class="fl">7.2</span>, <span class="fl">72.1</span>)
<span class="kw">within_n_mads</span>(<span class="dv">2</span>)(example.vector)(example.vector)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">within_n_mads</span>(<span class="dv">1</span>)(example.vector)(example.vector)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
<p>Tubular!</p>
</div>
<div id="row-wise-assertions-and-row-reduction-functions" class="section level3">
<h3>row-wise assertions and row reduction functions</h3>
<p>As cool as it’s been so far, this still isn’t enough to consitute a complete grammar of data integrity checking. To see why, check out the following small example data set:</p>
<pre class="sourceCode r"><code class="sourceCode r">example.data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x=</span><span class="kw">c</span>(<span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>,
                             <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>),
                         <span class="dt">y=</span><span class="kw">c</span>(<span class="dv">82</span>, <span class="dv">91</span>, <span class="dv">61</span>, <span class="dv">49</span>, <span class="dv">40</span>, <span class="dv">49</span>, <span class="dv">57</span>,
                             <span class="dv">74</span>, <span class="dv">78</span>, <span class="dv">90</span>, <span class="dv">61</span>, <span class="dv">49</span>, <span class="dv">51</span>, <span class="dv">62</span>, <span class="dv">68</span>))
(example.data)</code></pre>
<pre><code>##    x  y
## 1  8 82
## 2  9 91
## 3  6 61
## 4  5 49
## 5  9 40
## 6  5 49
## 7  6 57
## 8  7 74
## 9  8 78
## 10 9 90
## 11 6 61
## 12 5 49
## 13 5 51
## 14 6 62
## 15 7 68</code></pre>
<p>Can you spot the brazen outlier? You’re certainly not going to find it by checking the distribution of each <em>column</em>! All elements from both columns are within 2 standard deviations of their respective means.</p>
<p>Unless you have a <em>really</em> good eye, the only way you’re going to catch this mistake is by plotting the data set.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(example.data$x, example.data$y, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;&quot;</span>)</code></pre>
<p><img src="data:image/png;base64,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AhBAgGgDEICANwIIkDf0FAwBCCBAtAEIQMAbAQTIG3oKhgAEaoEgPwJTpkwx06ZNM4cddlh+GfApCFSSQBAE5tNPPzV6POigg9xfZpZ169Y1CxYsMPXr1888HKvnNWzlg1jVKCGVOfnkk83NN9+MACXkfhVbNd9//31zzTXXmF27dpkvfOELZu3ate5xzpw5pmbNmu5y+/bta1avXm06dOgQ28unB5TnralVq5Y59NBDTbdu3fLMgY9BID8Ce/fuNfXq1TPDhg1zP4Lbtm0zzZo1M82bNzfjx483y5YtM2qfrVu3zq+AKvwUNqAqhE1REIiCwF133WU6d+5stmzZYnr06OFEp2nTpqZ9+/bm448/NosXL46imCrJAwGqEswUAoHoCKxatcoNuZo0aWLU+1m+fLnZv3+/Wb9+vdmxY4d57rnnoiuswDkhQAUGTPYQiJrA1q1bjXo8svekUu3atZ0x+qOPPnKilDoe90dsQFl3aMWKFeaee+7JOlr65YsvvmjWrFljTj311NJvcgQCBSRQo0YNs2/fPic4ep5Ku3fvdj0g2X+SkpJT0yoiqm7tl7/85QpLe+ihh8yBAwcqPI8TIBA1gXbt2rm2p6n3devWmWOPPda88MILpk+fPqZXr16mZcuWURdZsPwQoCy0unm53MBvfOMb5rOf/WzWp3kJgcIT+NKXvuSm12+66SYzdOhQN+TSLJjWpn372982kydPLnwlIioBAYoIJNlAoKoIXHjhhWb27Nnmhz/8ofnb3/7mpt/VA+revbu54YYbjNaoJSUhQEm5U9QTAhkENNU+YcIEc84557gekNYATZ061ahnnqSEACXpblFXCGQQmDhxotFfkhPT8Em+e9QdAgkngAAl/AZSfQgkmQAClOS7R90hkHACCFDCbyDVh0CSCSBASb571B0CCSeAACX8BlJ9CCSZAAKU5LtH3QtOQP76tOXmgw8+MJ988knBy6tuBSRegNRAdu7cad59993qdu+43gIT+Ne//mUGDx5sPve5zzlvgy1atDAzZswocKnVK/tECpB8oFx33XVuCXqdOnXMkUceaT7/+c8796hyP3n11Ve7X6zqdSu52igJyL+OPF6q5/Pmm28auUCVf2W5QdV2B1I0BBK3Evqf//yn6dmzp5EbgvPPP9/oV+nwww93r9ULev31180jjzxi5s2bZ5566qmcNpZGg5JcionAbbfd5trW448/nr6sk046yWzevNkcd9xxZvTo0W4XevpNnuRFIHEC9JOf/MT1fJYuXWoOPvjgMi/6lltuMQMGDDCzZs1K/FL1Mi+QgwUn8PTTT5vp06eXKkfDsYEDBzovhHKDQaocgcQNweT/ZMSIEeWKj3DIO9yoUaMS5Ru3creRT0dNQAZntaOykhx+KRwOqfIEEidAcjmwcuXKCq9ckQEUroQEgXwIaJhflsFZESlmzpzpXF/kky+fKUkgcUMwOWCSCL311lsuLImch8kALe9wsgH94x//cL5SFi1aZDRMI0EgHwIyNqtdqT3Jlqhez/bt2408Zo4dO9a0adMmn2z5TBaBxAlQx44djfwxqxGMHDmyzK5wv379zJIlS0zv3r2zLrfil6+88oqLq1TRmQp/smfPnopO4/2EEtDEhno7p5xyimnQoIFp1KiRkc/l73//+y4WV0IvK3bVTpwAiWCrVq3cr5KmShUbSb9SEoSjjjrKLRaTSOXrmFuN7K9//WuFN0o2AJVJKl4C6lXLx7J61pqKV69HgkSKkIBCMyctvfTSS4HtAQV2KjR45plnXPXvuOOO4IgjjlCY6cD6ag5+9atfFfSyVIadJSloGWTuj4A1QgcNGzYMunTpEtip98D2hoI//OEPrn0l5b7bZQOBnbTxBzGHkhPXA3r55Zedz1stQLQNxMVG+sUvfmFuvPFGM2TIECOH3Q8//LC57LLL3DqNXCJcRKjnZFUkBLQOSDNhCr2USmeddZbrcZ9wwgmmf//+LjZX6j0e8yOQuFkwNYxOnTq5LvGmTZvM5ZdfbsaMGeNWPyuel0RIixDVQBTClgSBfAjI8JwZ+C+VhwICyg+z7XmnDvFYCQKJE6CNGze6UCT16tVzq58VIUBJq6Iz03nnnedWrWYe4zkEciUgA7TaWFmpbt26RhFISZUnkDgB0jSo1vikUup59i+ShmpHH3106jQeIRCKgCLezp07t9RnNCy79957TdeuXUu9x4HwBBJnAxo3bpzbZqHYR7IBqat81VVXmUmTJjm3CZqC1/4d2YW0YIwEgXwIaEOzfsA00zlt2jSXhTamtm3b1lxyySVG+8JIlSeQOAGSbUdhkSUw2qGs/TradqGFiVdeeWU6Xraep4ZnlcdEDtWNgFbRv/POO279z/z5840ij27YsMG557j77rurG46CXW/iBEgkZO/Jtvk8+OCDRhtV165da9q3b+8aTMGokXFkBGRL0eI+LRyV/x1NMGgzsXoavlNqMaLWmUmMtAteq6NJ0RFIpACVd/mNGzc2miolJYOA7Cny5aSFo/JcoC+8Htu1a2eee+45061bN+8Xog2pEh79kaInUFQCFD0eciwkAdlZDjvsMOfaIlWO4p1LkDTVLd9PhxxySOotHouQQOJmwYrwHlTbS3ryySeNNg1nJ4mPtttoOE0qbgIIUHHf31hfnfbdaaNnWUmOv9jsWxaZ4jqGABXX/UzU1XTu3NksXLiwVJ1lmNZSCvn3JhU3AWxAxX1/Y311119/vfPtpClvDbuU9u3bZz7zmc84n8s4lIv17YukcghQJBjJJB8CWm38/PPPG7vj3Oi5prg1+3XxxRcb7esjFT8BBKj473Gsr1DDMNl6tOtcK421gVgbPknVgwACVD3uc6yvsn79+qZv376xriOVKwwBjNCF4UquEIBADgToAWVB0pJ7LYCrKGkVr1zCkiAAgfwJIEBZ7FatWuW8K2YdLvVSszVvv/12qeMcCEfAeu10dp8nnnjC7QWTQfraa691m0DD5cTZSSSAAGXdNU0Hp6aEs94q8VJ2C/wNlUCS1wu50H3jjTeMPF1qL5j15e2CCygEMpFH80KaqA8hQIm6XcVV2R/96EdGIZDVC0qlPn36GM2MnXHGGcYGHzDyPkgqXgIYoYv33sb+yh577DGzevXqUvXUEMxGHXHx30q9yYGiIoAAFdXtTNbF7Ny5s9w1PxreYmNL1v3Mp7YIUD7U+EwkBORjZ+XKlaXyUtBHG4PLHH/88aXe40BxEUCAiut+Jupq5A9o8ODB5tVXX03XW/agmjVrmtatWzuXHOk3eFKUBDBCF+VtTcZFnX322S6IpMRm+PDhbhZMQQYUTFK74UnFTwABKv57HOsrVPw2+VyW8MgntF736NHDKC47qfgJIEDFf49jf4WKOHHRRRfFvp5UMHoC/MxEz5QcIQCBHAkgQDmC4jQIQCB6AokfgmnWZNeuXW7mREv5SWUT0KK/pUuXug203bt3d0Eba9VK/O0v+2I5mhgCiewBbdu2zVx33XWmefPmpk6dOi62lLzpKcSL/AhrelfOrUj/ITBmzBgj96dt2rQxCmk9fvx4o3hXH374IYgg4JVA4n4C5SqjZ8+epkaNGi46aosWLdz0rV6/++675vXXXzePPPKImTdvnptZadmypVfAvgtX1FG5N1W8rZkzZ7pY54MGDTJ//vOfzQUXXGDUMxI7EgR8EEicACn8cnPb89Fw4uCDDy6TmUL7DhgwwEXZnDhxYpnnVIeDGp5KdLSrXLvNzzzzTOfwXbHN9Z4WAMr/UcOGDasDDq4xhgQSJ0Dr1q0zI0eOLFd8xFjDi1GjRpk777zTVGcB0paGHTt2OLH5+OOPTabNR5En9u7da7Zs2YIAxfCLWV2qlDgbkAyoZe0fyr5hy5YtM9U9rIt6OfqbMWNGCfERq+3bt5sDBw7g1TG74fC6Sgkkrgc0dOhQF0vqrbfeMsOGDTOy8cgArZWzsgFpVe3s2bNdyF8N06pzUg9IafLkyWbEiBElREiRR2X7Ea9u3bpVZ0xcu0cCiROgjh07Oj8xY8eOdUOx1Jcsk2G/fv3MkiVLTO/evTMPV7vnGnJJZI488kg3LJ00aZKbNZw/f76bDfvLX/5iOnXqVO24cMHxIZA4ARK6Vq1auRkuOYWXDUO/4rJxNGnSxLlJVY8o33T//febSy+9tMKPqzzNuMU5qVd42mmnuWB/2tz5zDPPuCHXt771LbcL/ZBDDjFyiUGCgC8CNayN4P/9YfqqRUTlyoGVvlTyppdvEg7ZRipKGsL89Kc/NVpjE+ekHqKce8nmM3DgQMdHQ1M51d+9e7frEcW5/tQtfwJaEzdr1iy3Ni7/XAr7ycQZoYVDa1jkykG7p5UWLFjgpuYbNWpkGjRo4EL9rlixwr0X9p+GLJpFq+hP5+kv7km9oDfffNNt9tQM4h//+EfTq1cv521QizhJEPBJIHEC9Kc//ckZTRWXS0k+hc8991xniNYaoZ/97GeuBySn5vmKkM8bUoiy5WN58eLFRgb8cePGOcHu2rVrTj29QtSHPCGQJqAhWJLSFVdcEdiwOekqjx49OrDT7YG1yaSP6YkN9xJYFw8ljkX5wg7zgunTp0eZZUHysoKsIXZg1/yk87fDssCGFQpuv/329DGeFB+Bk046KbC93lhfWOJ6QGvWrDH9+/dPC6jsGF/5yldKTDHrTf3aa8hRnZPsPz//+c/N+vXr3QroFAsNHbVAUYs033vvvdRhHiFQ5QQSJ0BW1Z0bz48++sjB6tOnj9G0cmpIpoNW8p1Lz7Zt21Y50DgVKA4yPp944omlqpWaAcslDHWpD3MAAhERSNw0vHbBK3yvbBja1a2V0YqeoDU/djhmFLFUCxEV6jeXFdMRcYxlNnLuriUJW7duNcccc0yJOkqwN23a5JYulHiDFxCoQgKJEyC571y+fLm5+eabnSPzzJ5PSnC0uE69IglVdU9Dhgxxa4G0ViozqVfUtGlT9oFlQuF5lRNInACJULt27cxvfvMbt9lUiwHlH+j99993v+b6UsnvDek/BDQzKIfvsvvcd999LtTxnDlzXK9IO+Fx/k5L8UkgkQKUAqbhhf6++MUvpg7xmEVAwzAZ4+WWI7UAUcPVBx54gEWIWax4WfUEEi1AVY8rmSWq96OoE0SeSOb9K+ZaJ24WrJhvBtcGgepGAAGqbnec64VAjAgwBIvwZmhNjWbiNOTRfittAiVBAALlE6AHVD6bUO9oTZKM4QsXLjS///3v3RS3ZqBIEIBA+QToAZXPJud37J4q5/RdSwEOPfRQ97mpU6e6NTbacW73r+WcFydCoDoRoAdUybstx2SKwqFVxSnxUZZaHqA9WPIZlLlYspLF8XEIFBUBBKiSt1O+qSU88k0tj4Pnn3+++5PPIu1b+/e//2327NlTyVL4OASKkwBDsEreV0Vj1Y5yBUjUqmzFKtMmUAVHlE1IoW+08ZMEAQiUJoAAZTFZtGiRufXWW7OOln4pYZGnwXr16rm49BKfZ5991vTo0cOdrL1ochMigcLzYGl+HIGACCBAWe1AvZZcBEgeF+UXWm5hZXxW0kyYZr5k89F+KwX/03tyHaLnJAhAoCQBBKgkDxfCRmFsKkraYyVRSe3Al61nwoQJ5jvf+Y77aN++fd0m2cMPP9y89tprpn379hVlyfsQqHYEEKBK3nLFXVfS4sPsdT8KlKgkZ/kkCECgNAFmwUozCXVEs19yadG8efNSn5PPHQUHlB2IBAEIlCaAAJVmEuqIDMwyXCsmmZ5r3Y8WJio8kIzUcgSGEToUUk6uRgQYgkVws88880yzYcMGNwN2zTXXuBy1EFExuGzEjghKIAsIFCcBBCii+yoH+CmbT0RZkg0Eip4AQ7Civ8VcIATiSwABiu+9oWYQKHoCCFDR32IuEALxJYAAxffeUDMIFD2BxAuQNn7u3LkTA3DRN1UusBgJJFKAFAdMEVK1+E9rbLR1QtPeWvDXoUMHc/XVV5sPPvigGO8X1wSBoiKQuGl4+V3u2bOn2/og3ztyg6H9VtoKoWlw7UqXK4x58+a5gHxaqUyCAATiSSBxAqT9Vur5KMiefO+UleShcMCAAWbWrFlm4sSJZZ3CMQhAIAYEEjcEU5TPESNGlCs+Ylq7dm0zatQos3jx4hggpgoQKAwB2T9lapA7YPmnSmJKnAB179497QLjfwFftmwZ2yD+FyDeSzQBCc55553n2vhZZ51l6tevb37wgx8k7poSNwQbOnSokQjJF/OwYcOcL2YZoLUjXTYgbf6cPXu22yCqYRoJAsVGQIEQ5IlTtlDNAGsiZvfu3c5BnvyPT5kyJTGXnDgB6tixo3nxxRfN2LFjzciRI82nn35aCna/fv3MkiVLTO/evUu9xwEIJJ3APffcY5o0aWJWrFiRvhR5X9B3QYEQ1Ps//fTT0+/F+UniBEgwW7Vq5Wa49u/fb7Zs2eJ6PfpV0E1RNFL1iPJNa9asMXPnzq3w4/v27TPvvPNOhedxAgSiJiDf43L5kp00Ezxo0CCzfPlyBCgbTiFeq+spMdKfktyiahhWGQGqW7duTh4MFYqncePGhbgs8oTA/yQgd8DlxZrTD3GSorAksgdU3t159NFHzZVXXml27dpV3ikVHpfv5lz8N2udUevWrSvMjxMgEDUBDa/uvvtuNxucmbfERwEVVq1alXk41s8TJ0B33HGHG3KVRfXvf/+76wV985vfdG937tzZXHTRRWWdyjEIJJbA8OHDzfTp040c4WnCpWHDhmbz5s1uQkbr3k499dTEXFviBOj55593IW8UEifb26BmAvQrIE+ESuUtVIzi7sgG9PTTTxvVJzPp10czE6pf3JJCBMludsQRR8Stau6HQ/WTHS9uSfdaLnebNm0am6rJ1rl27VpnBpDxWRFa+vfv73YF/PKXv3T1TIKDvBp2MVMQG6o5VESwf/zjH7t47DfccIPb96UpeKUHHnig0kOwHKrgTlm9erW57777nNP5zM9o8aMWh8XxS64GqRhlcfySK76a6tesWbNMnLF4LmZvvPFG2tYYi0r9txKyBW3cuNGMGzeuVLW0Y0AmCdmMYpskQElMdrYqaNOmTXDaaacFdu2PuwS79SKwBmivl3P99dcHkyZN8lqH8gq/6667gssuu6y8t70eX7BgQXD22Wd7rUN5hb/wwguBXf5R3ttej1t7p/c2XxkAiVsJnVLyLl26uC7oCSec4NY+3H///am3eIQABBJCIHE2oEyumm60v+pGS9FlbCb8cSYdnkMg/gQS2wPKRCsBeumll5z1XyulSRCAQDIIJLoHlIlYTsl++9vfZh7iOQQgEHMCRdEDijljqgcBCJRDAAEqBwyHIQCBwhNAgArPmBIgAIFyCCBA5YDhMAQgUHgCiVsJXXgklStBjtLkFkFG8bglrTT+8MMPS21hiUM9tRJa7k20ejduSSuht27dao477ri4Vc3titceyHbt2sWubrlUCAHKhRLnQAACBSHAEKwgWMkUAhDIhQAClAslzoEABApCAAEqCFYyhQAEciGAAOVCiXMgAIGCEECACoKVTCEAgVwIIEC5UOIcCECgIAQQoIJgJVMIQCAXAghQLpQ4BwIQKAgBBKggWMkUAhDIhQAClAslzoEABApCAAEqCNb4ZmodiMe3cjGuWVy5xbVeud5KBChXUhWcd+mll5rjjz++1J/CRftOO3bsMF/72tdcyGpt9rz22mvNtm3bfFfL3HTTTS66rCLMZv8NHDjQe/3ESNzq169v6tWrZ/r162c2bNjgvV6qgI0EY2wUEaMQ4ccee6y5/PLLzXvvvReLuoWpRNG4ZA1z0YU4V/HAtCO5a9euJbKvXbt2iddV/UJB9VSno446yjz00EMuwN6ECRPM9u3bzYMPPljV1SlRniLXKpBkZlJwyTvvvNP07Nkz83CVP1fP4txzz3U79H/961+7L7ri0Cn438svv+xeV3ml/lug4s716tXLxfu6/fbbXXBCGwrKfP3rXzePP/54vOOAZUOzoEmVJGDdSGhcEyxcuLCSOUX/cRvCN7BRWoMtW7akM1c9bZTPwPaM0sfi8uSSSy4JbKilwPYcvVZp06ZN7p7OmDEjXQ8bcdcdUwwzn2nKlCmuHk8++WS6Gq+99po7pthvSUoMwbIVOY/Xisih1KlTJ/eo6K1xSTZYo/tlzAwrrOGNFSTTqFGjuFTT1WPZsmXGfuFdqCWFXPKZGjRoYBRxd8+ePelqHDhwwD3XsMdnUntT5N2+ffumq9GiRQsXH2/p0qXpY0l4ggBFcJfWr1/vbATTpk1z4XvVeAcPHuxixEeQfaWykNCceOKJZu7cuWbAgAHmlFNOcbaX1JepUplH+GENxcaMGWMGDRpkbLTbCHPOLysbYddceOGFZvLkyUZDsEcffdRcddVV5uSTTzbdu3fPL9OIPlWnTh03dM28h7bX49qbHKclKiWpuxbXul588cWu+zt06NDA2lWCkSNHBnXr1g06dOgQ2Ebirdq2JxbYxhqcfvrpgQ3aGKievXv3dnW94IILvNWrrIJ/97vfuXo99dRTZb3t5Zi1tQTt27d39bJf6sD+sJQYynqplC303nvvdXWyNr10FZYvX+6OKVx5kpJJUmXjWtcVK1YEc+bMKVG9qVOnugZhex4ljlfli71797o6WBexgWwaqXTjjTe642vWrEkd8v5oez5By5YtA4lmHJI10getWrUKrAE/kDhKGO3QNbDG/MD2eL1Wcf/+/U4Ya9asGdhZumD06NGBHRYGtnfmfvS8Vi5k4QhQSGC5ni4Dr7UhBOPHj8/1IwU5z04hB3ZIUyLvV155xQmQHTKWOO7rxa5du1xP7ZZbbvFVhVLlynivXs+rr76afk+Cri/6FVdckT7m64n17x3YpR9B27Ztg69+9auBtZ8Fw4cPL3WvfdUv13KZho9gwLx27Vo3LWt/MdO5afpdRkyN132mJk2amGOOOaZEFTQlr7rJeX4c0rx585xNY9SoUXGojqvDypUrjf1yO5teqlJ2GGvOOOMM8+yzz6YOeXu0M5vGimSJ8r/73e86G1WJgzF/gRE6ghtkf3ncgrXMrObPn29kJOzSpUvm4Sp/rsVz+sLYbnu67EWLFhnN1GWvWUqfUMVP1q1b50SycePGVVxy+cVJtLXYz/Z60ifpftrhtjn66KPTx3w8WbVqlRNGreVKJdtTM3ZI7RYnpo4l4jHXrhLnlU/AzpS47rpd4Be8/fbbgWwrNoRLYMXHu01Dtp9atWq57rmdIQms+AR2xXZgF7J5NZBn0pSR3C7wyzzk/fnmzZsDuxTA2X02btwY2NA3bshjv9TBE0884bV+n3zyibOXachlV2s7m5QmPIYMGeK1XvkUjg0oH2pZn5Hh9Hvf+56zY6iB6gt/zjnnBBqnxyFpAZ3dguFEUnWz60cC2V3ikuwwMbBT3HGpTroeMjzLEK17qj87NR/MnDkz/b7PJxLBHj16BJpgkF3KroIOtCA2aYm4YLZlRZU0zFG3XV103wvpyrom7W3SvibfC+nKqlucj2kvnYITNmvWLDZ2sxQvBcKUPci3rTFVn7CPCFBYYpwPAQhERgAjdGQoyQgCEAhLAAEKS4zzIQCByAggQJGhJCMIQCAsAQQoLDHOhwAEIiOAAEWGkowgAIGwBBCgsMQ4HwIQiIwAAhQZSjKCAATCEkCAwhLjfAhAIDICCFBkKMkIAhAISwABCkuM8yEAgcgIIECRoSQjCEAgLAEEKCwxzocABCIjgABFhpKMIACBsAQQoLDEOB8CEIiMAAIUGUoyggAEwhJAgMIS43wIQCAyAghQZCjJCAIQCEsAAQpLjPMhAIHICCBAkaEkIwhAICwBBCgsMc6HAAQiI4AARYaSjCAAgbAEEKCwxDgfAhCIjAACFBlKMoIABMISQIDCEuN8CEAgMgIIUGQoyQgCEAhLAAEKS4zzIQCByAggQJGhJCMIQCAsAQQoLDHOhwAEIiOAAEWGkowgAIGwBBCgsMQ4HwIQiIwAAhQZSjKCAATCEkCAwhLjfAhAIDICCFBkKMkIAhAISwABCkuM8yEAgcgIIECRoSQjCEAgLAEEKCwxzocABCIjgABFhpKMIACBsAQQoLDEOB8CEIiMAAIUGUoyggAEwhJAgMIS43wIQCAyAghQZCjJCAIQCEsAAQpLjPMhAIHICCBAkaEkIwhAICwBBCgsMc6HAAQiI4AARYaSjCAAgbAEEKCwxDgfAhCIjAACFBlKMoIABMISQIDCEuN8CEAgMgIIUGQoyQgCEAhLAAEKS4zzIQCByAggQJGhJCMIQCAsAQQoLDHOhwAEIiOAAEWGkowgAIGwBBCgsMQ4HwIQiIwAAhQZSjKCAATCEkCAwhLjfAhAIDICCFBkKMkIAhAISwABCkuM8yEAgcgIIECRoSQjCEAgLAEEKCwxzocABCIjgABFhpKMIACBsAT+D4DXycB9nRbfAAAAAElFTkSuQmCC" /></p>
<p>Ok, so all the <code>y</code>s are roughly 10 times the <code>x</code>s except the outlying data point.</p>
<p>The problem having to plot data sets to catch anomalies is that it is <em>really</em> hard to visualize 4-dimensions at once, and it is near impossible with high-dimensional data.</p>
<p>There’s no way of catching this anomaly by looking at each individual column separately; the only way to catch it is to view each row as a complete observation and compare it to the rest.</p>
<p>To this end, <code>assertr</code> provides two functions that take a data frame, and reduce each row into a single value. We’ll call them <em>row reduction functions</em>.</p>
<p>The first one we’ll look at is called <code>maha_dist</code>. It computes the average mahalanobis distance (kind of like multivariate z-scoring for outlier detection) of each row from the whole data set. The big idea is that in the resultant vector, big/distant values are potential anomalous entries. Let’s look at the distribution of mahalanobis distances for this data set…</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">maha_dist</span>(example.data)</code></pre>
<pre><code>##  [1]  1.28106379  3.10992407  0.25081851  1.35993969 12.81898913
##  [6]  1.35993969  0.26181283  0.47714597  0.87804987  2.95741956
## [11]  0.25081851  1.35993969  1.29208587  0.28235776  0.05969507</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">maha_dist</span>(example.data) %&gt;%<span class="st"> </span><span class="kw">hist</span>(<span class="dt">main=</span><span class="st">&quot;&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>)</code></pre>
<p><img src="data:image/png;base64,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rlXocrb14Ycf2rRp02yPPfawM844w+QkXrOSX3/99VTWon7XItfPPvss8qUoHN9++21RXyuVh0DSBCJbQJkVfO+990zO4BctWmSbNm2yww8/3OT+VOIkj31ao1XMqUOHDqZXVJo7d641adIkKhvHIQCBSghkJUDr1q1zzt7vu+8+e/75590/nvwea/uQQw5x5v/2t785d6Enn3yyW6NVSZkcggAEIOAIRArQ/PnzSwL9abxn+vTp1rNnT1MEivSkMSElOWUnQQACEMiGQGkVKecMeR+84YYbbODAgbbnnnuWk+O/u+SveM2aNXRLKiTEAQhAIJNA5CC0Bp8vvPBCmz17tr399tsl559//vmlBp7VImJMpAQPHyAAgSwIRAqQbPTo0cM98VILR0mhxDQxsXXr1m5ekNvJHwhAAAIxCUQK0JtvvmkK1qewMJ07d3bma9WqZQsWLLBbbrnFPfnSo2sSBCAAgbgEIgVozpw5pm5YeQ7eFXViy5YtpkfzJAhAAAJxCUQK0MEHH2wLFy601atXl7E9c+ZMk2fCpk2bljnGDghAAAJRBCIFqGPHji4Esub9PP300/b+++/bW2+9ZQ8++KALi3Pqqada3bp1o8rhOAQgAIEyBCIfwysG+3PPPWe9evWybt26lTJwyimn2J133llqHxsQgAAEsiUQKUAy1Lx5c1uyZIlr/SxevNh1u9Q1yyaGerYVIR8EIFDzCGQlQCkszZo1M70KNWlx6KpVq6xFixZlZmoXap2pFwRqMoGsBEhdMPkB0vhPeY/c5aojn0lTAu644w5XlyFDhthRRx1lN998s11//fXORcauu+7qts8555x8VouyIACBmAQiBUhPv44//nhr0KCBderUyXbbbbeYRfjNLvE57LDDrE6dOta4cWN76KGHbMKECXbllVda//793TiVFsaed955rot47LHH+q0A1iAAAW8EIgVI84B22GEHNwa0++67eys4V0O///3v7cc//rFbGqJ1anKOppbO2LFjnQjJroRIg+YaII8rQHI0pvGuqLRhwwbbvHlzVDaOQwAClRCIFCAtu9C4TyGIj65jxYoVNnjwYNtll13cZWl6wE033WSaDpCe9IRO3ca4Sd4fb7/99sjTtOp//fr1kfnIAAEIVEwgUoAU/viCCy6w5cuXl/j+qdhc9R+RB0bNRxo6dKgrTJ+V5CAs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" /></p>
<p>There’s no question here as to whether there’s an anomalous entry! But how do you check for this sort of thing using <code>assertr</code> constructs?</p>
<p>Well, <code>maha_dist</code> will typically be used with the <code>insist_rows</code> function. <code>insist_rows</code> takes a data frame, a row reduction function, a predicate-generating function, and an arbitrary number of columns to apply the predicate function to. The row reduction function (<code>maha_dist</code> in this case) is applied to the data frame, and returns a value for each row. The predicate-generating function is then applied to the vector returned from the row reduction function and the resultant predicate is applied to each element of that vector. It will raise an error if it finds any violations.</p>
<p>As always, this undoubtedly sounds far more confusing than it really is. Here’s an example of it in use</p>
<pre class="sourceCode r"><code class="sourceCode r">example.data %&gt;%
<span class="st">  </span><span class="kw">insist_rows</span>(maha_dist, <span class="kw">within_n_mads</span>(<span class="dv">3</span>), <span class="kw">everything</span>())</code></pre>
<pre><code>## Error: Data frame row reduction violates predicate 'within_n_mads' 1 time (at row number 5)</code></pre>
<p>Check that out! To be clear, this function is running the supplied data frame through the <code>maha_dist</code> function which returns a value for each row corresponding to its mahalanobis distance. (The whole data frame is used because we used the <code>everything()</code> selection function.) Then, <code>within_n_mads(3)</code> computes on that vector and returns a bounds checking predicate. The bounds checking predicate checks to see that all mahalanobis distances are within 3 median absolute deviations of each other. They are not, and the pipeline errors out.</p>
<p>This is probably the most powerful construct in <code>assertr</code>–it can find a whole lot of nasty errors that would be very difficult to check for by hand.</p>
<p>Part of what makes it so powerful is how flexible <code>maha_dist</code> is. We only used it, so far, on a data frame of numerics, but it can handle all sorts of data frames. To really see it shine, let’s use it on the iris data set, that contains a categorical variable in its right-most column…</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(iris)</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">iris %&gt;%<span class="st"> </span>maha_dist %&gt;%<span class="st"> </span><span class="kw">hist</span>(<span class="dt">main=</span><span class="st">&quot;&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>)</code></pre>
<p><img src="data:image/png;base64,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xWIx27lzp+3evZu7CQEI5BmBvBSgd99918aMGWNFRUX2pS99yZo3b25f+cpX7Mtf/rJ16dLFbr31Vtu/f3+e3QqKC4HCI1AvaEHE8umyN2/ebL169bJ69erZkCFDrG3bttasWTP3W62gjRs3WmlpqemyysrKrF27dvl0eZQVAgVFIO8E6MYbb7TVq1fbwoUL7eijj054sw4dOmQDBw608847z0pKShIew0YIQMA/gbx7BVu1apVdffXVNYqPkH7xi1+0kSNH2vz58/0TpgQQgECNBPJOgIqLi23JkiU1XlB8x6JFi6xVq1bxn/yFAAQiSOCoCJap1iJ95zvfMYnQf//7Xxs2bJjr41EHdP369d1I2KZNm2zGjBk2b94895pWa2bshAAEvBLIuz4g0Xrrrbds1KhRtnjxYvvss8+qAezfv7/deeed1rdv32r72AABCESHQF4KUBzfp59+alu2bDG1etTxfNJJJ1nr1q3dkHz8mLr+/fvf/25Tp04NPe21116zhx9+2Pr16xd6bF0P0LVIQLdu3VrXUysdr2kJDz30kDVs2LDSdn5AICoE8u4VrCI4zQFq3769+2j7jh07au2crnhuTd/btGljgwYNqml3+fbly5fb4cOHy39n8otE9YknnrApU6akle2kSZPslVdesT59+qSVDydDIGsENA8o39KyZcti3/rWt2L79u1zRZ8zZ07slFNO0Xym2Be+8IVYt27dYi+++GJWL6tnz56xf/7zn1mxEbxixoL5TWnn3bt371jwmpp2PmQAgWwRyLtRsEB8LHj47ciRI06Uly5dapdffrl77brvvvts8uTJduyxx9qAAQPspZdeyppwkzEEIJA+gbx7BfvjH/9ol1xyiQWtHnf106ZNs5YtW5qE6aij/nc5o0ePNnVE6zXm/PPPT58SOUAAAlkhkHctIPW9XHzxxeUw9u7d6/ps4uIT36Hhek1aJEEAAtElkHcCdPbZZ9tf/vIXO3jwoKP6jW98w7WG4q9k2hi8r9rf/vY369SpU3TJUzIIQMDy7hVMq+DPOecc69Gjh40dO9ZNSuzYsaMb6bnmmmuscePGbiLic889l9SMaeoABCDgj0DeCVAw2mXBCJfdc889Nnz48PLOaCGML9Ho2rWraxVJqEgQgEB0CeSdAAnlGWecYTNnznTzZOR+Q/6BPvjgAzcR8eSTT7bT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" /></p>
<p>Looks ok, but what happens when we accidently enter a row as a different species…</p>
<pre class="sourceCode r"><code class="sourceCode r">mistake &lt;-<span class="st"> </span>iris
(mistake[<span class="dv">149</span>,<span class="dv">5</span>])</code></pre>
<pre><code>## [1] virginica
## Levels: setosa versicolor virginica</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">mistake[<span class="dv">149</span>,<span class="dv">5</span>] &lt;-<span class="st"> &quot;setosa&quot;</span>

mistake %&gt;%<span class="st"> </span>maha_dist %&gt;%<span class="st"> </span><span class="kw">hist</span>(<span class="dt">main=</span><span class="st">&quot;&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>)</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAYAAAAUg66AAAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAAAfIElEQVR4Ae2dC5AU1dmGPy+geBdQFEERlIBAUERCKNQglBEvAUpFIgQjRtGoFQEVTQhKUCqReEFSBlFDRNFAAFOKBIgSCcQgIqAoXhDlEjAKIYKKKGL//Z7/n/13Zme3p4fu6enNc6p2d7r79Lk8febd0+fyfXt5fjACBCAAgQQI7J1AnmQJAQhAwBFAgGgIEIBAYgQQoMTQkzEEIIAA0QYgAIHECCBAiaEnYwhAAAGiDUAAAokRQIASQ0/GEIAAAkQbgAAEEiOAACWGnowhAAEEiDYAAQgkRgABSgw9GUMAAggQbQACEEiMAAKUGHoyhgAEECDaAAQgkBgBBCgx9GQMAQggQLQBCEAgMQIIUGLoyRgCEECAaAMQgEBiBBCgxNCTMQQggADRBiAAgcQIIECJoSdjCEAAAaINQAACiRFAgBJDT8YQgAACRBuAAAQSI4AAJYaejCEAAQSINgABCCRGAAFKDD0ZQwACCBBtAAIQSIwAApQYejKGAAQQINoABCCQGAEEKDH0ZAwBCCBAtAEIQCAxAghQYujJGAIQQIBoAxCAQGIEEKDE0JMxBCCAANEGIACBxAggQImhJ2MIQAABog1AAAKJEUCAEkNPxhCAAAJEG4AABBIjgAAlhp6MIQABBIg2AAEIJEYAAUoMPRlDAAIIEG0AAhBIjAAClBh6MoYABBAg2gAEIJAYAQQoMfRkDAEIIEC0AQhAIDECCFBi6MkYAhBAgGgDEIBAYgQQoMTQkzEEIIAA0QYgAIHECCBAiaEnYwhAAAGiDUAAAokRQIASQ0/GEIAAAkQbgAAEEiOAACWGnowhAAEEiDYAAQgkRgABSgw9GUMAAggQbQACEEiMAAKUGHoyhgAEECDaAAQgkBgBBCgx9GQMAQggQLQBCEAgMQIIUGLoyRgCEECAaAMQgEBiBBCgxNCTMQQggADRBiAAgcQIIECJoSdjCEAAAaINQAACiRFAgBJDT8YQgAACRBuAAAQSI4AAJYaejCEAAQSINgABCCRGAAFKDD0ZQwACCBBtAAIQSIwAApQYejKGAAQQINoABCCQGAEEKDH0ZAwBCCBAtAEIQCAxAghQYujJGAIQ2BcE2QQWLFhgEyZMyD6Z52jlypU2btw46969e9bVDz/80H7wgx9Y/fr1s87XdLB161abMmWKHXHEETVF4xoEah0BBCjnkR577LHWq1evnLNVD5cuXWpfffVVlQv333+/tW7d2r797W9XuVbdiRdffNGJ2R133FFdFM5DoFYSQIByHuvxxx9v+gkK6v0ceuiheaMdeeSR1q9fv7zX8p189913befOnfkucQ4CtZoAY0C1+vFSOQiUNwEEqLyfD6WDQK0mgADV6sdL5SBQ3gQQoPJ+PpQOArWaAAJUqx8vlYNAeRNAgMr7+VA6CNRqAghQrX68VA4C5U0AASrv50PpIFCrCSBAtfrxUjkIlDcBBKi8nw+lg0CtJpB6AfI8zzZv3mza0EmAAATSRSCVArRx40YbPny4NWvWzOrWrWvae9WgQQO3N6t9+/Y2bNgw+/TTT9P1JCgtBP4LCQRuRl24cKHNnDnTfvjDH5q+3EmHdevWWdeuXW2vvfayiy++2Jo3b+5MX+hYvaD333/fpk+fbjNmzLDnn3/eWrRokXSRyR8CEKiGQKAAHXbYYTZ37ly77777nABJiPr375+Y7ZqxY8e6ns9zzz1n++23X95qjRkzxnr27GmTJ0+2UaNG5Y3DSQhAIHkCga9g7dq1s1WrVtnLL79sZ5xxht155512zDHHWO/eve2pp56yXbt2lbQWK1assIEDB1YrPipMnTp1XI9tzpw5JS0bmUEAAuEIBApQJrmOHTuajG1t2rTJvZJpzEW9ocaNG9sNN9xgb731ViZqrH+7dOlif//73wPzmD9/vhPKwIhEgAAEEiMQ+AqWW7L169fb8uXLbdmyZbZ9+3br1KmTvfTSS06cfvazn9no0aNzb4n0+NJLLzWJkEyf6lVQYzwSw7333tuNAa1du9aZN509e7bpNY0AAQiUL4GCBGjLli02depUe/zxx23x4sXWqFEjZ/dYx23atHG1++Mf/2h9+/a1Pn36WIcOHWKr8cknn2yvvfaaDR482C677DL7+uuvq+TVo0cPmzdvnp155plVrgWd2L17d0GvlcpXSwAIEIBA8QQCBehvf/ub6QutcP7559vTTz/tBnj33Tf71nPPPdfFUc8k7nDCCSe4Ga4vv/zS1CNTr0djUXodbNKkiesRFVuGJ554wq666qrA27/44gs3NhbG9nNgokSAwH8ZgWwVyVP5Aw44wO66667AmS/NSP3rX/9yvaM8ycRySmuAJEb6UVCvRNPwstWcK5CFFkAeLfQTFCQ8md5fUFyuQwAC+QkEDkJr8PknP/mJ/eUvf7H33nuvIpUf//jHWQPP+sLr1awU4fXXX7err77aBg0aZHKjo3D33XfbUUcd5cTo8MMPt4kTJ5aiKOQBAQjsAYFAAVLa3/3ud92Ml3o4Chr7ePXVV61t27ZufZA7WaJfEp/TTjvNnnzySSc+Wu/z0EMP2e233+7c6ej82Wefbddcc40TzRIVi2wgAIEiCAQK0OrVq90XXV98zT4paNWxpsLvuece08yXxmJKFX75y1/aKaec4pYDyJ3Ntdde68ZstP1CQiR3OFoFfc4559gDDzxQqmKRDwQgUASBQAHSdga9hrVs2bJK8gMGDLAdO3a4geAqF2M68c4775im4g888EAnhJnxGm3LqBwuuuiirFfGytf4DAEIlAeBQAFq1aqVLVmyxDZs2FClxLNmzbJ99tmnpAv+NNOlRYaZkPn8wgsvZE65v+qxaUaMAAEIlC+BwFmwzp07u8Fd9TRGjhzpekLy4qmtGSNGjHAbQuvVq1eyGmrwWeM+Ggdq2LChm44fOnSo2yIiV8laMvDnP//ZuTqeNGlSycpFRhCAQHgCgQK0//77m3yXn3feeda9e/esHPSaU+pxFo3tTJs2zQnMtm3b3GyXtoRo/dGQIUPcALnGqPQ583qWVWgOIACBsiEQKEAqadOmTd3q43/+85+mzaB67dKrWSE+1OOoqcZ7csd8tCpbO+W1RUSzc8cdd1wcWZMmBCAQIYGCBCiTn8ZUynlc5eijj3Y9tUx5+QsBCJQ3gYIESK9gsgekHlC+KfelS5eWdy0pHQQgUJYEAgVIs18ad9H2Bm0/OOSQQ8qyIhQKAhBIH4FAAdI6IJm60A50bXEgQAACEIiKQOA6IG270LgP4hMVctKBAAQyBAIFqFu3bm5F8RtvvJG5h78QgAAEIiEQ+AqmdUDa+iDjXpdcconrDWkavnK4+eabKx/yGQIQgEBBBAIFSLveZe1QQWtt8gUEKB8VzkEAAkEEAgVIpji04pgAAQhAIGoCgWNAlTP87LPP3GyYvI7KJCkBAhCAwJ4QCOwBKXEtQJTrHdnZUZAXDNlOlhXEX/ziFyazrbUlvP3221m77aurl4yz4Y++Ojqch0BhBAIFSCufv/e975l2mt97773OAJmSPv300+2KK65wrnlqk/lTicrKlSsD6X3++ef0AgMpEQECNRMIFCD51tq4caPJEJhWQ992220uxQsvvNCtipZrHK0V0g702hC02rsQTxfyjaa9ZwQIQKB4AoFjQDLJKu8PEp/cIJs8H3zwgXOLk3uNYwhAAAJBBAIFSCY3ZP958+bNVdL6wx/+4MaB5CueAAEIQCAsgcBXsLPOOsstPpTjQVkelO8t9YqeeeYZmzBhglukKP9cBAhAAAJhCQQK0EEHHWRPPfWUyeqgVkQryBi9Qu/evZ1lQnfALwhAAAIhCQQKkNL75je/abL588orr7jej3o8Ghdq3bp1yOyIDgEIQOD/CRQkQIoukxwadNYPAQIQgEAUBAIFaPHixXbLLbfUmFeuS5waI3MRAhCAwP8RCBSg/fbbr8p6l+3btzu/8JkV0tCEAAQgUAyBQAGSG2T5W88NWnx4/fXXl9Qram4ZOIYABNJNIHAdUHXV08rnG2+80Znq0OZUAgQgAIGwBIoWIGUkZ4C7d+9O1FyHemJaJMnG0LCPnvgQSJ5A4CvY2rVr7emnn84qqURHX/iHHnrIOSgs9Upo7U27//77berUqW6fmjbKKshjR7NmzZx75lGjRpnWMBEgAIHyJRAoQKtWrbKbbrqpSg0OPPBAO/nkk0u+EHHdunXWtWtXt/lV3lGbN29u9evXd8cSxffff9+mT5/uTIfIo0eLFi2qlJ0TEIBAeRAIFCBtwSgn42Nyv6xejnbpa4YuXxgzZoz17NnTJk+ebOoJESAAgfIksEdjQElUSb7pBw4cWK34qEx16tRxW0fmzJmTRBHJEwIQKJBAYA+okIWIlfP63e9+516LKp+L8nOXLl3c7vwrr7yyxmTnz59vpR6bqrFAXIQABKoQCBQgOSSsV6+ezZ0717p3724nnXSSbdq0yb0Cffzxxya/YY0aNapIWGZa4wzaECsR0gxc//793RhPgwYN3FYRjQFp0HzKlCk2e/ZsV8Y4yxJV2qrLb37zG5s2bVrBScoiwcKFC914WME3ERECZUYgUC00k6TXHo25yDRHJmgm7LrrrnPmS/MtVMzEi/qvBr7lJnrw4MEma4wyD5IbevToYfPmzXO+zHKvlePxm2++aZ06dbLHHnus4OJJrGbOnIkAFUyMiOVIIFCA9EXWaujK4qOKyDnhiBEjnK0gWUUspXnSE044wTTDJXvV69evd72eXbt2WePGjV151CMqNsyaNctGjx4deLs8xa5Zs8Y6d+4cGLeQCBq3atmyZSFRXRw5AmDtU8G4iFimBAIFSGtrlixZYlrtnLuuRp4htEs+93yp6iqzIBIj/SjIbZC+lHsiQBKU8ePHB1ZBBvkleAQIQKB4AoECpNeZnTt32uWXX+56PFpXs2PHDlu0aJHbitG3b187+OCDiy9BhHfqlWTIkCG2ZcuWolNt2LCh6ScoSHQ1NkaAAASKJxAoQDJGL5vQF1xwgVt4WDkric+DDz5Y+VTsn3/961+7V658Gcmnl3pBGptS6NChgw0aNChfVM5BAAJlQCBQgFTG9u3bu/EOjXtoQFqroNu1a+e2YZS6DrLKKGP4mp3LnWbXrJzGghYsWOCKVd1CxVKXmfwgAIH8BAoSIN2qQdITTzzRjflo+4OOkwiaYpeJWK121oLEYcOGuTKpLJpF0itYIY4Fkyg7eUIAAtkECloJLcNjF110kRtsVm9I+8OGDx/uxoA0HlTKoEHvW2+91WSF8ZFHHnHrkLQ/jAABCKSPQKAAZVwzyzOqXDNn/MDLNfPDDz/sfMYnUe1TTz3Vli1b5ozjq0f06KOPJlEM8oQABPaAQOArWDm7ZpYYPvDAA3beeee5wWZmpfagJXArBBIgENgDSoNrZgmQxn3k010rpQkQgEA6CAT2gCq7Zj7iiCOyalVOrpmPPPLIvLarswrMAQQgUFYEAgUI18xl9bwoDARqFYFAAdKKX1wz16pnTmUgUDYEAgVIi/u0AFGroV9//XVcM5fNo6MgEEg/gUABevbZZ23AgAG2YcMGXDOn/3lTAwiUFYHAWbDMxsxt27aVVcEpDAQgkH4CgT0gTWvLCuEZZ5xhffr0cRYIc/dYDR06NP0kqAEEIFByAoECtHz5cvvTn/7kClad5UMEqOTPjQwhUCsIBArQOeec40xc1IraUgkIQKCsCOQdA5KnURkhI0AAAhCIk0DeHtC4cePs7rvvdt4vMplrR/wnn3xirVu3zpyqlX812C7Xz0FBVgAQ6SBKXIdAzQTyClC+W7QTXoa+li5dmu9yrTknf2Iyth8U5AJaokyAAASKJ1CwABWfRbru1EyffoKCNr5mjOEHxeU6BCCQn0DeMaD8UTkLAQhAIFoCCFC0PEkNAhAIQQABCgGLqBCAQLQEqh0D2rx5s7Vt27YiNzkhlMubyucyF7VJlQABCEAgLIG8AqTB1fPPPz8rLXnEIEAAAhCIkkBeAerVq5fphwABCEAgTgKMAcVJl7QhAIEaCSBANeLhIgQgECcBBChOuqQNAQjUSAABqhEPFyEAgTgJIEBx0iVtCECgRgIIUI14uAgBCMRJIO80fJwZknY0BGQ25LHHHrPXXnut4AS1mHTy5MnWoUOHgu8hIgTiJIAAxUk3xrRlKlfeYG+55ZaCc1myZIlNnDjRJkyYUPA9RIRAnAQQoDjpxpz2/vvvbz169Cg4l9WrVzv3SgXfQEQIxEwg9WNAnueZ9q1t3bo1ZlQkDwEIRE0glQIkk6nDhw+3Zs2aWd26dd2rSIMGDezQQw+19u3b27Bhw+zTTz+NmhXpQQACERNI3SvYunXrrGvXrrbXXnvZxRdfbM2bN7f69eu7Y/WCZCp1+vTpNmPGDHv++eedH7OImaU2uV27dtmiRYvsuuuuK7gOX3zxhY0cOdKaNm1a8D1ELI7A119/7cbnVq1aVXACegM4++yzU7t3M3UCNHbsWNfzee655yzXQWLmqY0ZM8Z69uzpZnxGjRqVOV3QX9m8njp1amBcCaFmlXJDnTp1nE3p//znP7mXqj3+6KOPbOXKlXbjjTdWGyf3gnqBy5YtC3XPwoULTaZT8plUyU0/cywb2ZMmTbILLrggc6qgv7IffuaZZxYUNxNJg+SdOnXKHBb0d8WKFSbnmWHCG2+8YW3atAlzi7399tv2jW98I9Q97733nvsHWehNn3/+uc2dO9f69etX6C2mfyq9e/c2CVEaw15+wVNVcvV+LrvsMrvyyitr5P3444/b+PHj7aWXXqoxXu5FfUHnzJmTe7rKsb78N998c5XGr/9i99xzT5X4QSfUowv7KPbdd1+TC6UwQQKpRhsmyCGluIcJixcvts6dO4e5xTk86NixY6h7SiVAb731lrVq1SpU2d555x1r2bJlqHsOOOAA03BCmKCJiLAiHCb9OOOmToD0pVeP4fe//32NXAYNGmQff/yxzZw5s8Z4XIQABJIjkLpXMPmp79Kli3344YfWv39/N8aj/xh77723mwlbu3atTZkyxWbPnm16TSNAAALlSyB1PSChfPfdd23w4MH2wgsvmF55coO6pD/96U+tW7duuZdiP37kkUdMXe9jjz021rzkk0wDxC1atIg1Hwm9epJhxz/CFkoTCJs2bQo1PhU2D8Xfvn27rVmzxk455ZRibi/4Ho3n6HX+tNNOK/ieYiLqdVqvoUFvBMWkXYp7UtcDEhSZjNUM15dffmnr16839Xr0IBo3bmxNmjQJ/Q4dJWgNIqpMYccywpZBjU5LDcQgzqCxD4ldPqGPMl89Q31h99lnnyiTrZKWJg40E6hFnHEGifasWbPsoIMOijMb551XkyZpFSANfBIiJOD3vLw777wzwhTzJ+W7zvaGDh2a/2KEZ/2G7fmD/hGmmD+pZ555xvPtkOe/GOHZF1980fOdSkaYYv6k/Fkzzx+Azn8xwrNbtmzx/CGICFMsbVKpXIgY678UEocABEpGAAEqGWoyggAEcgkgQLlEOIYABEpGAAEqGWoyggAEcgkgQLlEOIYABEpGAAEqGWoyggAEcgkgQLlEOIYABEpGAAEqGWoyggAEcgmkcitGbiXK6VhbF7SzXfaa4wz+AjS3+vvoo4+OMxuTWZHPPvvMrTCPM6NPPvnE/v3vfztTK3Hms2PHDvvggw9i38KiFeqyTRX3Fpbdu3c7UyEnnXRSnNhiSxsBig0tCUMAAkEEeAULIsR1CEAgNgIIUGxoSRgCEAgigAAFEeI6BCAQGwEEKDa0JAwBCAQRQICCCHEdAhCIjQACFBtaEoYABIIIIEBBhLgOAQjERgABig0tCUMAAkEEEKAgQlyHAARiI4AAxYaWhCEAgSACCFAQoZDXfZPeIe8or+iFeL9Iex1ziaetPkHlDbqeW/8kjxGgiOgvX77cOUo8/PDDnT/w0aNHR5Ry/Mlos6n80sutkdw9H3fccTZmzJgqbp8fffRR+853vmNyHywf7vLLloZw/fXXW6NGjaoUNU31kTuhCy+80Lmcatasmd100022cePGrDqlsg36aknYQwL+F9hr3ry59/3vf9/zfcZ7kyZN8vwvqXfHHXfsYcqluX3gwIGeL5zOndA//vEPT66FfCHyRowYUVGABQsWeHXr1vXGjx/v+Q3du/rqqz3ft5b36quvVsQpxw/z58/3fOsEnm+dIKt4aarPzp07Pd/RpeeLvud7+/WeeOIJ78QTT/R8z8AVdUprG8QvWMUjLP7Dbbfd5h1yyCGe7w2zIpFRo0Z5DRs29NR4yjn4DvQ836215/9HzSqm/98260vbunXrrAavyG3btvUGDRqUdV85HfheUD2/t+C1adMmqy4qY5rqM3HiRPcPwnd4WYH32Wef9Zo2ber5PSN3Lq1tkFewrE5scQfyhtqzZ88sb5u9evUy2ex5+eWXi0u0RHfJnsxvf/tbu+aaa7JyPP744002evzW7Tyjvvnmm9anT5+sOKrj7Nmzs86V04FeK32RtL59+2YVS55e01SfyZMn2yWXXGK+4FTU49xzz3UeeDOvlmltgwhQxSMt/oN81R9zzDFZCWSO9e5ezqF+/fp21VVXmQQnEzQQ/eSTT9q3vvUtZ1xt9erV7lKmTpl4Ot68eXPsbpsz+YX5O2/ePJs2bZpNmDChym1pq49cfbdr187kgln/6DT+pjHGr776qqJuaW2DCFDFIyz+g9/Vr+KP/rDDDnMJykJi2sKtt97qrAb+6le/ckVXT0jBdwHs/mZ+acBdPShZMiynsG3bNrviiits7NixVf4xqJxpqo96oPonNmPGDLv88stdfTQJMHLkSPPH7iqwp7UNIkAVj7D4D3Xq1HE9hcopyCyrwq5duyqfLvvP/sC53XXXXSbx0X9aBc2MKWTq5A4q/ZL50XIKN9xwg7Vq1cp+9KMf5S1WmurjjyGa+P71r3+1lStX2sMPP+xmH2+//XbXS33llVdcHdPaBhGgvE003MmjjjrK2U6ufJc/uOsODz744Mqny/qzpnZ//vOfO/HR+EkmZOxOZ+qUOS970Qr+AHzmVOJ/9eql6fVLL73UfVG1VEC2mfUl1ucNGzZYmupTr149Uxs6/fTTs+xY9+vXz7HOjDGmtQ3+77+2xJtNugugh5871iPD5wotWrRIReUkOPfee689+OCDbkyocqFVP4VMnTLXVGd/ps99QTLnkv67YsUKN3Duz85VKUq3bt1c727AgAHuWhrqo4JqfZY/DZ9VHz0Tf/ayolea1jZIDyjrsRZ30KNHD5szZ44bD8mk4E+Tup7BqaeemjlVtn/1yiXx8deXVBEfFVo9Bn8q21SnymHWrFl21llnVT6V+Gd/fZKtW7cu62fIkCFOKHV+8ODBqaqPgKp9LVq0yPXiMoA1+6jJAk0UZOKksg1WLCzgQ9EENm3a5Pnv4N61117rbd261fO7+p4/u+Tdd999RadZqhv9KWm3aLJjx46e1pvk/vivLq4o/lS9W3g4ffp0zx/k9fyV0u54zZo1pSpq0floTVbuQsQ01cef4XILQ/2em+e/Qnq++Hj+GJfnv5Z5/kyY45LWNshCxKKbdfaNfm/ALTz0/xs58fGntisaR3bM8joaN26cNq9V+yOxUVBDHzp0qBNaxddCPn+spbwqU01p8glQ2uqjldtaVCn2WqXuv056/jqzrBqnsQ3iF8x/olEFvzW4rn+TJk0qZo6iSrtc0tGszEcffVRlTKJcyhe2HGmrj/Z/aVC6uoH/tLVBBChsiyU+BCAQGQEGoSNDSUIQgEBYAghQWGLEhwAEIiOAAEWGkoQgAIGwBBCgsMSIDwEIREYAAYoMJQlBAAJhCSBAYYkRHwIQiIwAAhQZShKCAATCEkCAwhIjPgQgEBkBBCgylCQEAQiEJYAAhSVGfAhAIDICCFBkKEkIAhAISwABCkuM+BCAQGQEEKDIUJIQBCAQlgACFJYY8SEAgcgIIECRoSQhCEAgLAEEKCwx4kMAApERQIAiQ0lCEIBAWAIIUFhixIcABCIjgABFhpKEIACBsAQQoLDEiA8BCERGAAGKDCUJQQACYQkgQGGJER8CEIiMAAIUGUoSggAEwhJAgMISIz4EIBAZAQQoMpQkBAEIhCWAAIUlRnwIQCAyAghQZChJCAIQCEsAAQpLjPgQgEBkBBCgyFCSEAQgEJYAAhSWGPEhAIHICCBAkaEkIQhAICwBBCgsMeJDAAKREUCAIkNJQhCAQFgCCFBYYsSHAAQiI4AARYaShCAAgbAEEKCwxIgPAQhERgABigwlCUEAAmEJIEBhiREfAhCIjAACFBlKEoIABMISQIDCEiM+BCAQGQEEKDKUJAQBCIQlgACFJUZ8CEAgMgIIUGQoSQgCEAhLAAEKS4z4EIBAZAQQoMhQkhAEIBCWAAIUlhjxIQCByAggQJGhJCEIQCAsAQQoLDHiQwACkRFAgCJDSUIQgEBYAghQWGLEhwAEIiOAAEWGkoQgAIGwBBCgsMSIDwEIREYAAYoMJQlBAAJhCSBAYYkRHwIQiIwAAhQZShKCAATCEkCAwhIjPgQgEBkBBCgylCQEAQiEJYAAhSVGfAhAIDICCFBkKEkIAhAISwABCkuM+BCAQGQEEKDIUJIQBCAQlsD/AL0OXsAm7bJeAAAAAElFTkSuQmCC" /></p>
<pre class="sourceCode r"><code class="sourceCode r">mistake %&gt;%<span class="st"> </span>maha_dist %&gt;%<span class="st"> </span>which.max</code></pre>
<pre><code>## [1] 149</code></pre>
<p>Look at that! This mistake can easily be picked up by any reasonable bounds checker…</p>
<pre class="sourceCode r"><code class="sourceCode r">mistake %&gt;%<span class="st"> </span><span class="kw">insist_rows</span>(maha_dist, <span class="kw">within_n_mads</span>(<span class="dv">7</span>), <span class="kw">everything</span>())</code></pre>
<pre><code>## Error: Data frame row reduction violates predicate 'within_n_mads' 1 time (at row number 149)</code></pre>
<p><code>insist</code> and <code>insist_rows</code> are both similar in that they both take predicate generators and not actual predicates. What makes <code>insist_rows</code> different is its usage of a row-reduce data frame.</p>
<p><code>assert</code> has a row-oriented counterpart, too; it’s called <code>assert_rows</code>. <code>insist</code> is to <code>assert</code> as <code>insist_rows</code> is to <code>assert_rows</code>.</p>
<p><code>assert_rows</code> works the same as <code>insist_rows</code>, except that instead of using a predicate generator on the row-reduced data frame, it uses a regular-old predicate.</p>
<p>For an example of a <code>assert_rows</code> use case, let’s say that we got a data set (<code>another-dataset.csv</code>) from the web and we don’t want to continue processing the data set if any row contains more than two missing values (NAs). You can use the row reduction function <code>num_row_NAs</code> to reduce all the rows into the number of NAs they contain. Then, a simple bounds checker will suffice for ensuring that no element is higher than 2…</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read.csv</span>(<span class="st">&quot;another-dataset.csv&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">assert_rows</span>(num_row_NAs, <span class="kw">within_bounds</span>(<span class="dv">0</span>,<span class="dv">2</span>), <span class="kw">everything</span>()) %&gt;%
<span class="st">  </span>...</code></pre>
<p><code>assert_rows</code> can be used for anomaly detection as well. A future version of <code>assertr</code> may contain a cosine distance row reduction function. Since all cosine distances are contrained from -1 to 1, it is easy to use a non-dynamic predicate to disallow certain values.</p>
</div>
<div id="combining-chains-of-assertions" class="section level3">
<h3>combining chains of assertions</h3>
<p>Let’s say that as part of an automated pipeline that grabs mtcars from an untrusted source and finds the average miles per gallon for each number of engine cylinders, we want to perform the following checks…</p>
<ul>
<li>that the dataset contains more than 10 observations</li>
<li>that the column for ‘miles per gallon’ (mpg) is a positive number</li>
<li>that the column for ‘miles per gallon’ (mpg) does not contain a datum that is outside 4 standard deviations from its mean, and</li>
<li>that the am and vs columns (automatic/manual and v/straight engine, respectively) contain 0s and 1s only</li>
</ul>
<p>This could be written thusly:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">verify</span>(<span class="kw">nrow</span>(mtcars) &gt;<span class="st"> </span><span class="dv">10</span>) %&gt;%
<span class="st">  </span><span class="kw">verify</span>(mpg &gt;<span class="st"> </span><span class="dv">0</span>) %&gt;%
<span class="st">  </span><span class="kw">insist</span>(<span class="kw">within_n_sds</span>(<span class="dv">4</span>), mpg) %&gt;%
<span class="st">  </span><span class="kw">assert</span>(<span class="kw">in_set</span>(<span class="dv">0</span>,<span class="dv">1</span>), am, vs) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Source: local data frame [3 x 2]
## 
##   cyl  avg.mpg
## 1   4 26.66364
## 2   6 19.74286
## 3   8 15.10000</code></pre>
<p>Ew, there are four lines of assertions before the real fun starts. We can make look much better by abstracting out all the assertions:</p>
<pre class="sourceCode r"><code class="sourceCode r">check_me &lt;-<span class="st"> </span>. %&gt;%
<span class="st">  </span><span class="kw">verify</span>(<span class="kw">nrow</span>(mtcars) &gt;<span class="st"> </span><span class="dv">10</span>) %&gt;%
<span class="st">  </span><span class="kw">verify</span>(mpg &gt;<span class="st"> </span><span class="dv">0</span>) %&gt;%
<span class="st">  </span><span class="kw">insist</span>(<span class="kw">within_n_sds</span>(<span class="dv">4</span>), mpg) %&gt;%
<span class="st">  </span><span class="kw">assert</span>(<span class="kw">in_set</span>(<span class="dv">0</span>,<span class="dv">1</span>), am, vs)

mtcars %&gt;%
<span class="st">  </span>check_me %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Source: local data frame [3 x 2]
## 
##   cyl  avg.mpg
## 1   4 26.66364
## 2   6 19.74286
## 3   8 15.10000</code></pre>
<p>Awesome! Now we can add an arbitrary number of assertions, as the need arises, without touching the real logic.</p>
</div>
<div id="advanced-send-email-reports-using-custom-error-functions" class="section level3">
<h3>advanced: send email reports using custom error functions</h3>
<p>One particularly cool application of <code>assertr</code> is to use it as a data integrity checker for frequently updated data sources. A script can download new data as it becomes available, and then run <code>assertr</code> checks on it. This makes <code>assertr</code> into a sort of “continuous integration” tool (but for data, not code.)</p>
<p>In an unsupervised “continuous integration” environment, you need a way to discover that the assertions failed. In CI-as-a-service in the software world, failed automated checks often send an email of reporting the maintainer of a botched build; why not bring that functionality to <code>assertr</code>?!</p>
<p>All assertion verbs in <code>assertr</code> support a custom error function. By default, the error function is R’s built-in <code>stop</code> function, which displays a message and halts execution. You can specify your own to hijack this behavior and redirect flow-of-control wherever you want.</p>
<p>All custom error functions take one argument: the actual error message that <code>assertr</code> assembles based on which assertions fail. In this case, we will build a function that takes that message and emails it to someone before halting execution. We will use the <code>mailR</code> package to send the mail.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mailR)

email_me &lt;-<span class="st"> </span>function(err_str){
  <span class="kw">send.mail</span>(<span class="dt">from=</span><span class="st">&quot;assertr@gmail.com&quot;</span>, <span class="dt">to=</span><span class="st">&quot;YOU@gmail.com&quot;</span>,
            <span class="dt">subject=</span><span class="st">&quot;error from assertr&quot;</span>, <span class="dt">body=</span>err_str,
            <span class="dt">smtp =</span> <span class="kw">list</span>(<span class="dt">host.name=</span><span class="st">&quot;aspmx.l.google.com&quot;</span>, <span class="dt">port=</span><span class="dv">25</span>),
            <span class="dt">authenticate =</span> <span class="ot">FALSE</span>, <span class="dt">send=</span><span class="ot">TRUE</span>)
  <span class="kw">stop</span>(err_str, <span class="dt">call.=</span><span class="ot">FALSE</span>)
}

questionable_mtcars %&gt;%
<span class="st">  </span><span class="kw">verify</span>(<span class="kw">nrow</span>(.) &gt;<span class="st"> </span><span class="dv">10</span>, <span class="dt">error_fun=</span>email_me) %&gt;%
<span class="st">  </span><span class="kw">verify</span>(mpg &gt;<span class="st"> </span><span class="dv">0</span>, <span class="dt">error_fun=</span>email_me) %&gt;%
<span class="st">  </span><span class="kw">insist</span>(<span class="kw">within_n_sds</span>(<span class="dv">4</span>), mpg, <span class="dt">error_fun=</span>email_me) %&gt;%
<span class="st">  </span><span class="kw">assert</span>(<span class="kw">in_set</span>(<span class="dv">0</span>,<span class="dv">1</span>), am, vs, <span class="dt">error_fun=</span>email_me)
  <span class="co"># ...</span></code></pre>
<p>(this particular <code>send.mail</code> formulation will only for gmail receptients; see the <code>mailR</code> documentation for more information)</p>
<p>Now you’ll get notified of any failed assertions via email. Groovy!</p>
</div>
<div id="advanced-creating-your-own-predicate-generators-for-insist" class="section level3">
<h3>advanced: creating your own predicate generators for <code>insist</code></h3>
<p><code>assertr</code> is build with robustness, correctness, and extensibility in mind. Just like <code>assertr</code> makes it easy to create your own custom predicates, so too does this package make it easy to create your own custom predicate generators.</p>
<p>Okay… so its, perhaps, not <em>easy</em> because predicate generators by nature are functions that return functions. But it’s possible!</p>
<p>Let’s say you wanted to create a predicate generator that checks if all elements of a vector are within 3 times the vector’s interquartile range from the median. We need to create a function that looks like this</p>
<pre class="sourceCode r"><code class="sourceCode r">within_3_iqrs &lt;-<span class="st"> </span>function(a_vector){
  the_median &lt;-<span class="st"> </span><span class="kw">median</span>(a_vector)
  the_iqr &lt;-<span class="st"> </span><span class="kw">IQR</span>(a_vector)
  <span class="kw">within_bounds</span>((the_median-the_iqr*<span class="dv">3</span>), (the_median+the_iqr*<span class="dv">3</span>))
}</code></pre>
<p>Now, we can use it on <code>mpg</code> from <code>mtcars</code> like so:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">insist</span>(within_3_iqrs, mpg) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Source: local data frame [3 x 2]
## 
##   cyl  avg.mpg
## 1   4 26.66364
## 2   6 19.74286
## 3   8 15.10000</code></pre>
<p>There are two problems with this, though…</p>
<ol style="list-style-type: decimal">
<li>We may want to abstract this so that we can supply an arbitrary number of IQRs to create the bounds with</li>
<li>We lose the ability to choose what optional arguments (if any) that we give to the returned <code>within_bounds</code> predicate.</li>
</ol>
<p>Now we have to write a function that returns a function that returns a function…</p>
<pre class="sourceCode r"><code class="sourceCode r">within_n_iqrs &lt;-<span class="st"> </span>function(n, ...){
  function(a_vector){
    the_median &lt;-<span class="st"> </span><span class="kw">median</span>(a_vector)
    the_iqr &lt;-<span class="st"> </span><span class="kw">IQR</span>(a_vector)
    <span class="kw">within_bounds</span>((the_median-the_iqr*n), (the_median+the_iqr*n), ...)
  }
}</code></pre>
<p>Much better! Now, if we want to check that every <code>mpg</code> from <code>mtcars</code> is within 5 IQRs of the median and <em>not allow NA values</em> we can do so like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">insist</span>(<span class="kw">within_n_iqrs</span>(<span class="dv">5</span>), mpg) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(cyl) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">avg.mpg=</span><span class="kw">mean</span>(mpg))</code></pre>
<pre><code>## Source: local data frame [3 x 2]
## 
##   cyl  avg.mpg
## 1   4 26.66364
## 2   6 19.74286
## 3   8 15.10000</code></pre>
<p>Super!</p>
</div>
<div id="advanced-programming-with-assertion-functions" class="section level3">
<h3>advanced: programming with assertion functions</h3>
<p>The assertion functions we have been using so far have been using non-standard evaluation (we haven’t been quoting the column names, for example). Though very very nice in most cases, non-standard evaluation causes issues when trying to programmatically use assertion functions. Let’s say you want to check the z-scores of a column from <code>mtcars</code> of the user’s choice; you ask the user for a column and store that in a variable. If you try to use that variable in an <code>insist</code> (or <code>assert</code>, etc…) you’ll get an error</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># a.column &lt;- readline(&quot;Enter a column name: &quot;)</span>
<span class="co"># pretend user said &quot;vs&quot;</span>
a.column &lt;-<span class="st"> &quot;vs&quot;</span>
<span class="kw">insist</span>(mtcars, <span class="kw">within_n_sds</span>(<span class="dv">3</span>), a.column)</code></pre>
<pre><code>## Error: All select() inputs must resolve to integer column positions.
## The following do not:
## *  a.column</code></pre>
<p>Good thing all of <code>assertr</code>’s assertion verbs have standard evaluation counterparts! All you have to do to use them is put an underscore (“_“) at the end of the function name…</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">insist_</span>(mtcars, <span class="kw">within_n_sds</span>(<span class="dv">3</span>), a.column) %&gt;%
<span class="st">  </span><span class="kw">head</span>(<span class="dt">n=</span><span class="dv">2</span>)</code></pre>
<pre><code>##               mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4
## Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4</code></pre>
<p>Nifty!</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
